While quite a few iterations are needed (around 1570) not a lot of calculations are done in each iteration. For each iteration we only calculate $a(q)$ and $arcLength(q, a)$. Thus the algorithm runs in $\mathcal{O}(n)$ and the execution time for our intital values is around 1 second. While the incrementation of $q$ (0.001) and the comparator for arc length (1e-5) are limiting factors for the precision of our output we do get close. Calculating y(q, x) with the values we found give us $1.836970198721030e-17$, which is fairly close to 0. See appendix A for implementation.

We did also implement an algorithm that uses the same assumptions and incrementation step for $q$ but instead of just calculating $a$ we used the matlab function ode45 (a solver for ordinary differential equations that uses an explicit Runge-Kutta method). This method would give us one x-value just before the function intersects the x-axis and one just below. Then using the secant method we could interpolate a more precise value for $a$ until either the arc length was close enough to 0.5 or it was time to pick a new $q$. Using this algorithm we did get an arc length of the same precision. However, calculating y(q, a) with these values gives us $-8.741237924993000e-03$, which is significantly less precise. While it did take fewer iterations (excluding the iterations done by ode45) it does take around 2 seconds to execute. See appendix B for implementation.

An algorithm I did not manage to implement properly was to use the upper and lower bounds of $a$ as start values for the secant method. However, the problem with that algorithm was to find a find a proper value for $q$ to calculate y(x). One solution was to perform the secant method for N steps before we increment $q$ by 0.001 but since we have the relationship $a(q)$ the secant method would be redundant.